<h1>Archetype Inheritance</h1>
<p class="note">Learn how to extend CIN archetypes using Blueprint inheritance for maximum flexibility and code reuse. This is the professional approach used in shipped games.</p>

<div class="page-meta">
  <span class="time"><i data-lucide="clock"></i> 8 minutes</span>
  <span class="difficulty"><i data-lucide="bar-chart-2"></i> Intermediate</span>
</div>

<div class="callout tip">
  <span class="icon"><i data-lucide="lightbulb"></i></span>
  <div>
    <strong>Philosophy:</strong> Archetypes provide the foundation,  you provide the game-specific implementation. This separation creates maintainable, reusable AI systems that scale with your project.
  </div>
</div>

<h2>Why Archetype Inheritance?</h2>

<h3>❌ The Wrong Approach</h3>
<pre><code>// Monolithic AI Controller with everything hardcoded
BP_EnemySoldier
  ├─ Attack logic (Blueprint spaghetti)
  ├─ Cover finding (hardcoded algorithm)
  ├─ Reload logic (copied from tutorial)
  ├─ Perception setup (duplicated)
  └─ Squad behavior (tightly coupled)

Problems:
  - Hard to maintain
  - Can't reuse for other soldiers
  - Changes require editing every AI
  - No separation of concerns
  - Difficult to test</code></pre>

<h3>✅ The Right Approach</h3>
<pre><code>// Layered architecture with clear responsibilities
DA_Soldier_Preset (Data Asset)
  └─ Archetype: BaseCombat
     ├─ Foundation Actions: Attack, TakeCover, Reload, Retreat
     ├─ Foundation Services: PerceptionMonitor
     └─ Recommended Inputs: Health, Ammo, Threat

BP_Soldier (Blueprint extends BaseCombat foundations)
  ├─ Game-specific actions: ThrowGrenade, MeleeFinisher
  ├─ Visual/Audio: Animation, VFX, SFX
  ├─ Custom inputs: GrenadeCount, CanMelee
  └─ Weapon integration: Your weapon system

BP_EliteS oldier (Blueprint extends BP_Soldier)
  ├─ Enhanced actions: TacticalGrenade, Suppression
  ├─ Different stats: More health, better aim
  └─ Elite-specific: Better cover evaluation

Benefits:
  - Reusable foundation
  - Clear separation of concerns
  - Easy to extend
  - Testable components
  - Maintainable architecture</code></pre>

<h2>The Inheritance Pattern</h2>

<h3>Level 1: Archetype (Built-in Foundation)</h3>
<p><strong>What it provides:</strong></p>
<ul>
  <li>Core action set (Attack, Cover, etc.)</li>
  <li>Essential services (PerceptionMonitor)</li>
  <li>Recommended inputs (Health, Ammo)</li>
  <li>Default configurations</li>
</ul>

<p><strong>Provided by:</strong> CIN Plugin</p>

<h3>Level 2: Base Preset (Your Game Foundation)</h3>
<p><strong>What you add:</strong></p>
<ul>
  <li>Game-specific actions</li>
  <li>Custom services</li>
  <li>Input overrides</li>
  <li>Squad configurations</li>
</ul>

<p><strong>Created by:</strong> You (once per game genre)</p>

<h3>Level 3: Variant Presets (Specialized AI)</h3>
<p><strong>What you customize:</strong></p>
<ul>
  <li>Tuned scoring curves</li>
  <li>Different momentum/resistance values</li>
  <li>Additional actions</li>
  <li>Role-specific behavior</li>
</ul>

<p><strong>Created by:</strong> You (per AI type)</p>

<h2>Practical Example: FPS Game</h2>

<h3>Step 1: Create Base Preset</h3>

<p>Create <code>DA_BaseFPSSoldier_Preset</code> (your game's soldier foundation):</p>

<pre><code>Archetype: BaseSquadCombat
  └─ Inherits: Attack, TakeCover, Reload, Retreat, FlankLeft, FlankRight

Add Custom Actions:
  ├─ DA_Action_ThrowGrenade
  ├─ DA_Action_MeleeAttack
  ├─ DA_Action_CallForBackup
  └─ DA_Action_UseHealthPack

Add Custom Services:
  ├─ Service_WeaponManager (tracks ammo, weapon state)
  └─ Service_InventoryMonitor (tracks grenades, health packs)

Named Input Overrides:
  ├─ Health: bound to GAS attribute
  ├─ AmmoCount: bound to weapon system
  ├─ GrenadeCount: custom input
  └─ HasHealthPack: custom input

Squad Configuration:
  ├─ Team ID: 1 (enemies)
  └─ Enable squad coordination</code></pre>

<h3>Step 2: Create Variant Presets</h3>

<p><strong>Assault Soldier:</strong> <code>DA_AssaultSoldier_Preset</code></p>
<pre><code>Base: DA_BaseFPSSoldier_Preset

Modifications:
  ├─ Attack: Higher base score (70 → 80)
  ├─ Attack: Lower momentum (prevents hesitation)
  ├─ TakeCover: Lower priority (more aggressive)
  ├─ ThrowGrenade: Higher score (grenade-focused)
  └─ Retreat: Higher health threshold (retreats earlier)</code></pre>

<p><strong>Sniper:</strong> <code>DA_Sniper_Preset</code></p>
<pre><code>Base: DA_BaseFPSSoldier_Preset

Modifications:
  ├─ Attack: Add distance bonus (prefer far targets)
  ├─ TakeCover: Add "find high ground" logic
  ├─ Flank: Disabled (snipers don't flank)
  ├─ Retreat: Lower threshold (stays in fight longer)
  └─ New action: Relocate (find new sniper nest)</code></pre>

<p><strong>Medic:</strong> <code>DA_Medic_Preset</code></p>
<pre><code>Base: DA_BaseFPSSoldier_Preset

Modifications:
  ├─ Attack: Lower priority (support role)
  ├─ TakeCover: Higher priority (stays safe)
  ├─ New action: HealAlly (primary role)
  ├─ New action: SupplyAmmo
  └─ New service: Service_AllyHealthMonitor</code></pre>

<h3>Step 3: Apply to Pawns</h3>

<pre><code>// AI Controller for all soldiers
BP_FPSAIController
  ├─ UtilityBrainComponent
  ├─ AIPerceptionComponent
  ├─ CINQuickSetupComponent
  │  └─ Agent Preset: [Set per pawn type]
  └─ CINDebugComponent (optional)

// Assault pawn
BP_AssaultSoldier
  ├─ AI Controller: BP_FPSAIController
  ├─ QuickSetup preset: DA_AssaultSoldier_Preset
  └─ Visuals: Assault rifle, light armor

// Sniper pawn
BP_Sniper
  ├─ AI Controller: BP_FPSAIController
  ├─ QuickSetup preset: DA_Sniper_Preset
  └─ Visuals: Sniper rifle, ghillie suit

// Medic pawn
BP_Medic
  ├─ AI Controller: BP_FPSAIController
  ├─ QuickSetup preset: DA_Medic_Preset
  └─ Visuals: Med pack, support gear</code></pre>

<h2>Creating Custom Actions</h2>

<h3>Example: Throw Grenade Action</h3>

<p><strong>Create <code>DA_Action_ThrowGrenade</code>:</strong></p>

<pre><code>Action Name: "ThrowGrenade"
Base Score: 55.0

Considerations:
  1. Has Grenades
     Input: GrenadeCount
     Curve: 0.0→0, 1.0→100
     Reason: Can't throw without grenades
  
  2. Enemy Clustered
     Input: EnemyClusterSize
     Curve: 1.0→20, 3.0→100
     Reason: More effective against groups
  
  3. Safe to Throw
     Input: ThreatLevel
     Curve: 0.0→100, 1.0→30
     Reason: Don't throw when under heavy fire

Momentum:
  Max Momentum: 2.0
  Score Reduction: 20.0
  Decay Time: 5.0
  Reason: Don't spam grenades

Locking:
  Unlock Time: 3.0 seconds
  Reason: If throw fails, wait before retry

Executor:
  Type: Behavior Tree
  BT: BT_ThrowGrenade
    ├─ Aim at cluster center
    ├─ Calculate arc
    ├─ Play throw animation
    ├─ Spawn grenade projectile
    └─ Take cover after throw</code></pre>

<h3>Adding Custom Inputs</h3>

<p><strong>In your Character class:</strong></p>

<pre><code>// Blueprint Example
Event: On Grenade Count Changed
  Get AI Controller
  → Get Component By Class (UtilityBrainComponent)
  → Set Named Input Value
     Name: "GrenadeCount"
     Value: Current Grenades / Max Grenades

// C++ Example
void AYourCharacter::OnGrenadeCountChanged(int32 NewCount, int32 MaxCount)
{
    if (AAIController* AI = Cast<AAIController>(GetController()))
    {
        if (UUtilityBrainComponent* Brain = AI->FindComponentByClass<UUtilityBrainComponent>())
        {
            float Normalized = (float)NewCount / (float)MaxCount;
            Brain->SetNamedInputValue(TEXT("GrenadeCount"), Normalized);
        }
    }
}

// Or use a custom service
UService_InventoryMonitor
  └─ TickService()
     {
         float GrenadePercent = Owner->GetGrenadeCount() / Owner->GetMaxGrenades();
         Brain->SetNamedInputValue(TEXT("GrenadeCount"), GrenadePercent);
         
         float HealthPackPercent = Owner->HasHealthPack() ? 1.0f : 0.0f;
         Brain->SetNamedInputValue(TEXT("HasHealthPack"), HealthPackPercent);
     }</code></pre>

<h2>Extending Services</h2>

<h3>Custom Service Example</h3>

<p><strong>Create Custom Weapon Service:</strong></p>

<div class="code-tabs-container">
  <div class="code-tabs-header">
    <button class="code-tab-button" data-lang="blueprint">Blueprint</button>
    <button class="code-tab-button" data-lang="cpp">C++</button>
  </div>
  
  <div class="code-tab-content">
    <pre><code>// Blueprint - Weapon manager service
1. Create Blueprint Class → Utility Service
2. Name: "BP_Service_WeaponManager"

// Add Variables
- bPublishAmmoInputs (bool): true
- bPublishWeaponStateInputs (bool): true
- WeaponComponent (Weapon Component): None

// Override Event: Tick Service
Event Tick Service (Delta Time)
  → Branch: Is Valid (Brain) AND Is Valid (OwnerPawn)?
    False: Return
    
  → Get Component by Class (Weapon Component)
  → Set WeaponComponent
  → Branch: Is Valid (WeaponComponent)?
    False: Return
  
  → Branch: bPublishAmmoInputs?
    True:
      → Get Current Ammo (WeaponComponent)
      → Get Max Ammo (WeaponComponent)
      → Divide Current by Max
      → Set Named Input Value (Brain, "AmmoCount", Result)
      
      → Branch: Current Ammo > 0?
        True: Set Named Input Value (Brain, "HasAmmo", 1.0)
        False: Set Named Input Value (Brain, "HasAmmo", 0.0)
  
  → Branch: bPublishWeaponStateInputs?
    True:
      → Is Reloading (WeaponComponent)
      → Set Named Input Value (Brain, "IsReloading", Result as 0/1)
      
      → Can Fire (WeaponComponent)
      → Set Named Input Value (Brain, "CanFire", Result as 0/1)

// Configure in Details Panel
Min Interval: 0.1
bEnabled: true</code></pre>
  </div>
  
  <div class="code-tab-content">
    <pre><code class="language-cpp">// Service_WeaponManager.h
#include "UtilityService.h"
#include "Service_WeaponManager.generated.h"

UCLASS()
class YOURGAME_API UService_WeaponManager : public UUtilityService
{
    GENERATED_BODY()
    
protected:
    virtual void TickService(float DeltaTime) override;
    
    UPROPERTY(EditAnywhere)
    bool bPublishAmmoInputs = true;
    
    UPROPERTY(EditAnywhere)
    bool bPublishWeaponStateInputs = true;
};

// Service_WeaponManager.cpp
void UService_WeaponManager::TickService(float DeltaTime)
{
    Super::TickService(DeltaTime);
    
    if (!Brain || !OwnerPawn)
        return;
    
    UWeaponComponent* Weapon = OwnerPawn->FindComponentByClass<UWeaponComponent>();
    if (!Weapon)
        return;
    
    if (bPublishAmmoInputs)
    {
        float AmmoPercent = (float)Weapon->GetCurrentAmmo() / (float)Weapon->GetMaxAmmo();
        Brain->SetNamedInputValue(TEXT("AmmoCount"), AmmoPercent);
        
        bool bHasAmmo = Weapon->GetCurrentAmmo() > 0;
        Brain->SetNamedInputValue(TEXT("HasAmmo"), bHasAmmo ? 1.0f : 0.0f);
    }
    
    if (bPublishWeaponStateInputs)
    {
        bool bIsReloading = Weapon->IsReloading();
        Brain->SetNamedInputValue(TEXT("IsReloading"), bIsReloading ? 1.0f : 0.0f);
        
        bool bCanFire = Weapon->CanFire();
        Brain->SetNamedInputValue(TEXT("CanFire"), bCanFire ? 1.0f : 0.0f);
    }
}</code></pre>
  </div>
</div>

<p><strong>Add to Preset:</strong></p>
<pre><code>DA_BaseFPSSoldier_Preset
  └─ Extra Services
     └─ Service_WeaponManager
        ├─ MinInterval: 0.1 (update 10x per second)
        ├─ bPublishAmmoInputs: true
        └─ bPublishWeaponStateInputs: true</code></pre>

<h2>Common Inheritance Patterns</h2>

<h3>Pattern 1: Role Specialization</h3>
<pre><code>BaseSquadCombat (Archetype)
  └─ DA_Soldier_Preset (Your base)
     ├─ DA_AssaultSoldier (Aggressive, close range)
     ├─ DA_SupportSoldier (Defensive, suppression)
     ├─ DA_Sniper (Long range, patience)
     └─ DA_Medic (Support, healing)</code></pre>

<h3>Pattern 2: Difficulty Tiers</h3>
<pre><code>BaseCombat (Archetype)
  └─ DA_BaseEnemy_Preset (Your base)
     ├─ DA_EasyEnemy (Low health, simple AI)
     ├─ DA_NormalEnemy (Balanced)
     ├─ DA_HardEnemy (High health, smart AI)
     └─ DA_EliteEnemy (Boss-lite, special abilities)</code></pre>

<h3>Pattern 3: Faction Variations</h3>
<pre><code>BaseCombat (Archetype)
  └─ DA_BaseSoldier_Preset (Shared foundation)
     ├─ DA_PlayerFactionSoldier (Team 0, blue)
     ├─ DA_EnemyFactionSoldier (Team 1, red)
     └─ DA_NeutralFactionSoldier (Team 2, yellow)</code></pre>

<h2>Testing Your Inheritance</h2>

<h3>Verification Checklist</h3>

<div class="callout tip">
  <span class="icon"><i data-lucide="check-square"></i></span>
  <div>
    <strong>Before Deploying:</strong>
    <ul class="compact">
      <li>✅ Base preset has all common actions</li>
      <li>✅ Variants only override what's different</li>
      <li>✅ No duplicated actions across presets</li>
      <li>✅ Services are reusable</li>
      <li>✅ Input names are consistent</li>
      <li>✅ All variants share same AI Controller</li>
    </ul>
  </div>
</div>

<h3>Debug Your Hierarchy</h3>

<p><strong>Use Gameplay Debugger:</strong></p>
<ol>
  <li>Select Assault Soldier → Press <kbd>'</kbd> → <kbd>5</kbd></li>
  <li>Note which actions are active</li>
  <li>Select Sniper → Press <kbd>'</kbd> → <kbd>5</kbd></li>
  <li>Compare action lists - should see differences</li>
  <li>Verify shared actions (Attack, Reload) behave consistently</li>
</ol>

<h2>Best Practices</h2>

<h3>DO: Keep Base Preset Minimal</h3>
<pre><code>✅ DA_BaseSoldier_Preset
  └─ Only actions ALL soldiers need
  └─ Only services ALL soldiers use
  └─ Only inputs ALL soldiers publish</code></pre>

<h3>DON'T: Bloat Base with Specific Features</h3>
<pre><code>❌ DA_BaseSoldier_Preset
  └─ ThrowGrenade (only assaults have grenades)
  └─ Snipe (only snipers snipe)
  └─ HealAlly (only medics heal)
// These should be in variant presets!</code></pre>

<h3>DO: Use Data Inheritance, Not Code Duplication</h3>
<pre><code>✅ Create variant presets that reference base
❌ Copy-paste base preset for each variant</code></pre>

<h3>DO: Document Your Hierarchy</h3>
<pre><code>// Add comments to your presets
DA_BaseFPSSoldier_Preset
  Description: "Foundation for all FPS soldier AI. Provides basic combat, 
                squad coordination, and perception. Extend for role-specific 
                behaviors (assault, sniper, medic, etc.)"

DA_AssaultSoldier_Preset
  Description: "Aggressive close-combat specialist. High attack priority,
                grenade usage, lower retreat threshold. Extends DA_BaseFPSSoldier."</code></pre>

<h2>Troubleshooting</h2>

<h3>Issue: "Variants behaving identically"</h3>

<p><strong>Cause:</strong> Not actually overriding actions</p>

<p><strong>Solution:</strong></p>
<ul>
  <li>Verify variant preset has modified action scores</li>
  <li>Check Gameplay Debugger - scores should differ between variants</li>
  <li>Ensure you're applying correct preset to each pawn type</li>
</ul>

<h3>Issue: "Changes to base not affecting variants"</h3>

<p><strong>Cause:</strong> Variants duplicated base instead of referencing it</p>

<p><strong>Solution:</strong></p>
<ul>
  <li>Use archetype system properly - don't copy actions</li>
  <li>Variants should ADD or OVERRIDE, not duplicate entire action sets</li>
</ul>

<h3>Issue: "Too many presets to maintain"</h3>

<p><strong>Cause:</strong> Over-specialization</p>

<p><strong>Solution:</strong></p>
<ul>
  <li>Consolidate similar AI into one preset with runtime modifiers</li>
  <li>Use ScoreModifier property for runtime tuning instead of new presets</li>
  <li>Consider: Do you really need 10 variants, or just 3 well-tuned ones?</li>
</ul>

<h2>Next Steps</h2>

<div class="next-steps">
  <a class="button primary" href="#/docs/action-patterns">
    <i data-lucide="target"></i>
    Action Design Patterns
  </a>
  <a class="button" href="#/docs/service-configuration">
    <i data-lucide="settings"></i>
    Service Configuration
  </a>
</div>

<h3>Related Topics</h3>
<ul>
  <li><a href="#/docs/best-practices"><i data-lucide="star"></i> Best Practices</a> - Professional patterns for using archetypes</li>
  <li><a href="#/docs/archetype-guide"><i data-lucide="layers"></i> Archetype Guide</a> - Choosing the right archetype</li>
  <li><a href="#/docs/archetypes"><i data-lucide="layers"></i> All 11 Archetypes</a> - Complete archetype reference</li>
  <li><a href="#/examples/combat-setup"><i data-lucide="crosshair"></i> Combat Example</a> - See inheritance in action</li>
</ul>

<script>lucide.createIcons();</script>
